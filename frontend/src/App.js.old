import React, { useEffect, useState } from 'react';
import { BrowserRouter as Router, Routes, Route, useNavigate, useParams } from 'react-router-dom';
import './App.css';
import Modal from './components/Modal';
import InputModal from './components/InputModal';
import CampaignDetail from './pages/CampaignDetail';
import Layout from './components/Layout';
import BrowseCampaigns from './pages/BrowseCampaigns';
import CreateCampaign from './pages/CreateCampaign';
import MyCampaigns from './pages/MyCampaigns';
import About from './pages/About';
import { useWeb3 } from './hooks/useWeb3';
import { useModals } from './hooks/useModals';
import { useCampaignOperations } from './hooks/useCampaignOperations';
import { getProgressPercentage, isDeadlinePassed, canFinalizeCampaign } from './utils/campaignUtils';

function App() {
  // Custom hooks
  const { modal, inputModal, showModal, closeModal, showInputModal, closeInputModal } = useModals();
  const { contract, account, networkError } = useWeb3(showModal);
  const { campaigns, loading, loadCampaigns, donate, finalizeCampaign, claimRefund } = 
    useCampaignOperations(contract, account, showModal);

  // Load campaigns when contract is ready
  useEffect(() => {
    if (contract && account) {
      loadCampaigns();
    }
  }, [contract, account, loadCampaigns]);
    }, [contract, account, loadCampaigns]);

  // Helper function for donation input
  const handleDonation = (campaignId) => {
    showInputModal(
      'Make a Donation',
      'Enter donation amount in ETH:',
      '0.1',
      (amount) => {
        if (amount && parseFloat(amount) > 0) {
          donate(campaignId, amount);
        }
      }
    );
  };

  // Modal helper functions
  const showModal = useCallback((title, message, type = 'info', onConfirm = null) => {
    setModal({
      isOpen: true,
      title,
      message,
      type,
      onConfirm
    });
  }, []);

  const closeModal = useCallback(() => {
    setModal(prev => ({ ...prev, isOpen: false }));
  }, []);

  const showInputModal = useCallback((title, label, placeholder, onSubmit) => {
    setInputModal({
      isOpen: true,
      title,
      label,
      placeholder,
      onSubmit
    });
  }, []);

  const closeInputModal = useCallback(() => {
    setInputModal(prev => ({ ...prev, isOpen: false }));
  }, []);

  const initializeProvider = useCallback(async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        const web3Provider = new ethers.BrowserProvider(window.ethereum);

        // Check network
        const network = await web3Provider.getNetwork();
        const chainId = Number(network.chainId);
        
        // Check if we're on localhost (chainId 31337)
        if (chainId !== 31337) {
          setNetworkError(`⚠️ Wrong Network! You're on chain ID ${chainId}. Please switch MetaMask to "Localhost 8545" (Chain ID: 31337)`);
          showModal(
            'Wrong Network',
            `You're connected to chain ID: ${chainId}\n\nYou need to be on: Localhost 8545 (Chain ID: 31337)\n\nPlease switch networks in MetaMask!`,
            'warning'
          );
          return;
        } else {
          setNetworkError('');
        }

        const accounts = await window.ethereum.request({ 
          method: 'eth_requestAccounts' 
        });
        setAccount(accounts[0]);

        const web3Signer = await web3Provider.getSigner();

        const campaignContract = new ethers.Contract(
          CONTRACT_ADDRESS,
          CharityCampaignFactoryABI.abi,
          web3Signer
        );
        setContract(campaignContract);

        // Listen for account changes
        window.ethereum.on('accountsChanged', (accounts) => {
          setAccount(accounts[0]);
          window.location.reload();
        });

        // Listen for network changes
        window.ethereum.on('chainChanged', (chainId) => {
          window.location.reload();
        });

      } catch (error) {
        console.error('Error connecting to MetaMask:', error);
        showModal('MetaMask Required', 'Please install MetaMask to use this application!', 'error');
      }
    } else {
      showModal('MetaMask Required', 'Please install MetaMask to use this application!', 'error');
    }
  }, [showModal]);

  useEffect(() => {
    initializeProvider();
  }, [initializeProvider]);

  const loadCampaigns = useCallback(async () => {
    if (!contract || !account) return;
    
    try {
      setLoading(true);
      const count = await contract.getCampaignCount();
      const campaignList = [];

      // Fetch all metadata from backend
      const allMetadata = await campaignAPI.getAllMetadata();
      const metadataMap = {};
      allMetadata.forEach(meta => {
        metadataMap[meta.campaignId] = meta;
      });

      for (let i = 0; i < count; i++) {
        const campaign = await contract.getCampaign(i);
        const contribution = await contract.getContribution(i, account);
        const metadata = metadataMap[i] || {};
        
        campaignList.push({
          id: i,
          beneficiary: campaign[0],
          title: campaign[1],
          description: campaign[2],
          goalAmount: ethers.formatEther(campaign[3]),
          deadline: new Date(Number(campaign[4]) * 1000),
          totalRaised: ethers.formatEther(campaign[5]),
          finalized: campaign[6],
          refundEnabled: campaign[7],
          creator: campaign[8],
          userContribution: ethers.formatEther(contribution),
          // Off-chain metadata
          imageUrl: metadata.imageUrl,
          category: metadata.category,
          location: metadata.location,
          detailedDescription: metadata.detailedDescription,
          websiteUrl: metadata.websiteUrl
        });
      }

      setCampaigns(campaignList);
    } catch (error) {
      console.error('Error loading campaigns:', error);
    } finally {
      setLoading(false);
    }
  }, [contract, account]);

  useEffect(() => {
    if (contract) {
      loadCampaigns();
    }
  }, [contract, loadCampaigns]);

  const createCampaign = async (e) => {
    e.preventDefault();
    try {
      setLoading(true);
      
      // Create campaign on blockchain
      const tx = await contract.createCampaign(
        newCampaign.beneficiary,
        newCampaign.title,
        newCampaign.description,
        ethers.parseEther(newCampaign.goalAmount),
        parseInt(newCampaign.durationDays)
      );
      
      const receipt = await tx.wait();
      
      // Get the campaign ID from the event
      const event = receipt.logs.find(log => {
        try {
          return contract.interface.parseLog(log).name === 'CampaignCreated';
        } catch {
          return false;
        }
      });
      
      let campaignId;
      if (event) {
        const parsedEvent = contract.interface.parseLog(event);
        campaignId = Number(parsedEvent.args[0]);
      } else {
        // Fallback: get latest campaign ID
        const count = await contract.getCampaignCount();
        campaignId = Number(count) - 1;
      }
      
      // Save metadata to backend
      if (newCampaign.category || newCampaign.location || newCampaign.imageFile) {
        await campaignAPI.saveMetadata(
          campaignId,
          {
            category: newCampaign.category,
            location: newCampaign.location,
            detailedDescription: newCampaign.detailedDescription,
            websiteUrl: newCampaign.websiteUrl
          },
          newCampaign.imageFile
        );
      }
      
      showModal('Success!', 'Campaign created successfully!', 'success');
      setNewCampaign({
        beneficiary: '',
        title: '',
        description: '',
        goalAmount: '',
        durationDays: '',
        category: '',
        location: '',
        detailedDescription: '',
        websiteUrl: '',
        imageFile: null
      });
      await loadCampaigns();
    } catch (error) {
      console.error('Error creating campaign:', error);
      showModal('Error', 'Error creating campaign: ' + error.message, 'error');
    } finally {
      setLoading(false);
    }
  };

  const donate = async (campaignId, amount) => {
    try {
      setLoading(true);
      const tx = await contract.donate(campaignId, {
        value: ethers.parseEther(amount)
      });
      await tx.wait();
      showModal('Success!', 'Donation successful! Thank you for your contribution.', 'success');
      await loadCampaigns();
    } catch (error) {
      console.error('Error donating:', error);
      showModal('Error', 'Error donating: ' + error.message, 'error');
    } finally {
      setLoading(false);
    }
  };

  const finalizeCampaign = async (campaignId) => {
    try {
      setLoading(true);
      const tx = await contract.finalizeCampaign(campaignId);
      await tx.wait();
      showModal('Success!', 'Campaign finalized! Funds have been transferred to the beneficiary.', 'success');
      await loadCampaigns();
    } catch (error) {
      console.error('Error finalizing campaign:', error);
      showModal('Error', 'Error finalizing: ' + error.message, 'error');
    } finally {
      setLoading(false);
    }
  };

  const claimRefund = async (campaignId) => {
    try {
      setLoading(true);
      const tx = await contract.claimRefund(campaignId);
      await tx.wait();
      showModal('Success!', 'Refund claimed successfully! Funds have been returned to your wallet.', 'success');
      await loadCampaigns();
    } catch (error) {
      console.error('Error claiming refund:', error);
      showModal('Error', 'Error claiming refund: ' + error.message, 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleDonation = (campaignId) => {
    showInputModal(
      'Make a Donation',
      'Enter donation amount in ETH:',
      '0.1',
      (amount) => {
        if (amount && parseFloat(amount) > 0) {
          donate(campaignId, amount);
        }
      }
    );
  };

  const getProgressPercentage = (raised, goal) => {
    return Math.min((parseFloat(raised) / parseFloat(goal)) * 100, 100).toFixed(1);
  };

  const isDeadlinePassed = (deadline) => {
    return new Date() > deadline;
  };
  
  const canFinalizeCampaign = (campaign) => {
    // Can finalize if deadline passed OR if goal is fully reached
    const deadlinePassed = new Date() > campaign.deadline;
    const goalReached = parseFloat(campaign.totalRaised) >= parseFloat(campaign.goalAmount);
    return deadlinePassed || goalReached;
  };

  // Wrapper component for campaign detail page
  const CampaignDetailPage = () => {
    const { campaignId } = useParams();
    const navigate = useNavigate();
    const [refreshKey, setRefreshKey] = useState(0);

    const handleDonationWithRefresh = (campaignId) => {
      showInputModal(
        'Make a Donation',
        'Enter donation amount in ETH:',
        '0.1',
        async (amount) => {
          if (amount && parseFloat(amount) > 0) {
            await donate(campaignId, amount);
            setRefreshKey(prev => prev + 1); // Trigger refresh
          }
        }
      );
    };

    const handleFinalizeWithRefresh = async (campaignId) => {
      await finalizeCampaign(campaignId);
      setRefreshKey(prev => prev + 1); // Trigger refresh
    };

    const handleRefundWithRefresh = async (campaignId) => {
      await claimRefund(campaignId);
      setRefreshKey(prev => prev + 1); // Trigger refresh
    };

    return (
      <Layout account={account} loading={loading} networkError={networkError}>
        <CampaignDetail
          key={refreshKey}
          campaignId={parseInt(campaignId)}
          contract={contract}
          account={account}
          onBack={() => navigate('/')}
          onDonate={handleDonationWithRefresh}
          onFinalize={handleFinalizeWithRefresh}
          onClaimRefund={handleRefundWithRefresh}
          showModal={showModal}
          showInputModal={showInputModal}
        />
        
        {/* Custom Modal for Notifications */}
        <Modal
          isOpen={modal.isOpen}
          onClose={closeModal}
          title={modal.title}
          message={modal.message}
          type={modal.type}
          onConfirm={modal.onConfirm}
        />

        {/* Custom Input Modal for User Input */}
        <InputModal
          isOpen={inputModal.isOpen}
          onClose={closeInputModal}
          onSubmit={inputModal.onSubmit}
          title={inputModal.title}
          label={inputModal.label}
          placeholder={inputModal.placeholder}
          type="number"
        />
      </Layout>
    );
  };

  return (
    <Router>
      <Routes>
        {/* Browse Campaigns Page */}
        <Route path="/" element={
          <Layout account={account} loading={loading} networkError={networkError}>
            <BrowseCampaigns
              campaigns={campaigns}
              loading={loading}
              account={account}
              handleDonation={handleDonation}
              finalizeCampaign={finalizeCampaign}
              claimRefund={claimRefund}
              getProgressPercentage={getProgressPercentage}
              isDeadlinePassed={isDeadlinePassed}
              canFinalizeCampaign={canFinalizeCampaign}
            />
            
            {/* Custom Modal for Notifications */}
            <Modal
              isOpen={modal.isOpen}
              onClose={closeModal}
              title={modal.title}
              message={modal.message}
              type={modal.type}
              onConfirm={modal.onConfirm}
            />

            {/* Custom Input Modal for User Input */}
            <InputModal
              isOpen={inputModal.isOpen}
              onClose={closeInputModal}
              onSubmit={inputModal.onSubmit}
              title={inputModal.title}
              label={inputModal.label}
              placeholder={inputModal.placeholder}
              type="number"
            />
          </Layout>
        } />

        {/* Create Campaign Page */}
        <Route path="/create" element={
          <Layout account={account} loading={loading} networkError={networkError}>
            <CreateCampaign
              newCampaign={newCampaign}
              setNewCampaign={setNewCampaign}
              createCampaign={createCampaign}
              loading={loading}
            />
            
            {/* Custom Modal for Notifications */}
            <Modal
              isOpen={modal.isOpen}
              onClose={closeModal}
              title={modal.title}
              message={modal.message}
              type={modal.type}
              onConfirm={modal.onConfirm}
            />
          </Layout>
        } />

        {/* My Campaigns Page */}
        <Route path="/my-campaigns" element={
          <Layout account={account} loading={loading} networkError={networkError}>
            <MyCampaigns
              campaigns={campaigns}
              account={account}
              loading={loading}
              finalizeCampaign={finalizeCampaign}
              getProgressPercentage={getProgressPercentage}
              canFinalizeCampaign={canFinalizeCampaign}
            />
            
            {/* Custom Modal for Notifications */}
            <Modal
              isOpen={modal.isOpen}
              onClose={closeModal}
              title={modal.title}
              message={modal.message}
              type={modal.type}
              onConfirm={modal.onConfirm}
            />

            {/* Custom Input Modal for User Input */}
            <InputModal
              isOpen={inputModal.isOpen}
              onClose={closeInputModal}
              onSubmit={inputModal.onSubmit}
              title={inputModal.title}
              label={inputModal.label}
              placeholder={inputModal.placeholder}
              type="number"
            />
          </Layout>
        } />

        {/* About Page */}
        <Route path="/about" element={
          <Layout account={account} loading={loading} networkError={networkError}>
            <About />
          </Layout>
        } />

        {/* Campaign Detail Page */}
        <Route path="/campaign/:campaignId" element={<CampaignDetailPage />} />
      </Routes>
    </Router>
  );
}

export default App;
